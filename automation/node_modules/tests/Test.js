/**
 * @class      Test
 * @brief      The testing superclass
 * @details    This class is subclassed by all tests. It contains commonly used methods during tests to streamline
 * test creation.
 * @authors    Jack Cole jcole2@mail.sfsu.edu
 * @ingroup    tests
 */

const severity = { none: 0, info: 1, warning: 2, error: 3, fatal: 4 };

class Test {

	static get severity()     { return severity; }
	get name()                { return "Test"; }
	get browser()             { return this._browser; }
	get page()                { return this._page; }
	get options()             { return this._options; }

	// ============================================================
	constructor( page, browser, options ) {
	// ============================================================
		this._browser             = browser;
		this._page                = page;
		this._options             = options;

		this.ui = { element : {
				table          : '.table',           // TABLE
				minProbSlider  : '.min-prob-slider', // MIN_SCORE
				highlightInput : '.highlight-input', // HIGHLIGHT_FILTER
				filterInput    : '.filter-input',    // FILTER_INPUT
			}
		}
	}

	/**
	* Runs the test
	* @return {Promise}
	*/
	// ============================================================
	async execute() {
	// ============================================================
		return new Promise(( resolve, reject ) => {
			reject( 'The Test class must be inherited for implementation.' );
		})
	}

	// Fundamental UI
	// ============================================================
	async navigate( url ) {
	// ============================================================
		if( typeof url === 'undefined' ) { url = this.options.url; }
		if( ! url.match( /^http/i )) { url = `${this.options.url}/${url}`; url = url.replace( /\/+/g, '/' ); url = url.replace( 'http:/', 'http://' ); url = url.replace( 'https:/', 'https://' ); }
		await this.page.goto( url, { waitUntil: 'networkidle2' }).catch(( reason )=>{ reject( `Unable to connect. ${reason}` )});
		return this.pageToLoad();
	}

	// Fundamental UI
	// ============================================================
	async click( target ) {
	// ============================================================
		await this.page.click( target );
		return this.page.waitFor( 500 ); // Emulate user pause after clicking with mouse
	}

	// Fundamental UI
	// ============================================================
	async type( text ) {
	// ============================================================
		return this.page.keyboard.type( text, { delay: this.options.puppeteer.typingSpeed });
	}

	// Fundamental UI
	// ============================================================
	async pageToLoad() {
	// ============================================================
		return this.page.waitForNavigation({ timeout: 3000, waitUntil: 'networkidle2' }).catch(() => {});
	}

	// ============================================================
	pageMatch( pattern ) {
	// ============================================================
		let url = String( this.page.url().split( '/' ).pop() );

		if( typeof pattern === 'string' ) { pattern = new RegExp( pattern ); }

		return url.match( pattern );
	}

	// ============================================================
	login() {
	// ============================================================
		return new Promise( async( resolve, reject ) => {
			try {
				await this.navigate();
				if( this.options.login === undefined || this.options.login === undefined ) reject( 'Login or Password not set' );

				await this.click( '#email' );
				await this.type( this.options.login );
				await this.click( '#password' );
				await this.type( this.options.password );
				await this.click( 'button' );
				await this.pageToLoad();
				if( ! this.pageMatch( 'search.php' )) { reject( 'Login not redirected to search page' ); }
				resolve();

			} catch( e ) {
				reject( e );
			}
		});
	}

	// ============================================================
	logout() {
	// ============================================================
		return new Promise( async ( resolve, reject ) => {
			try {
				await this.click( '.user-info-and-logout a' );
				await this.pageToLoad();
			
				if( ! this.pageMatch( 'index.php' )) { reject( 'Logout not redirected to landing page' ); }
				resolve();

			} catch( e ) {
				reject( e );
			}
		});
	}
	
	// ============================================================
	// Search Modes
	// ============================================================
	searchMode( mode ) {
		return new Promise( async ( resolve, reject ) => { 
			try { 
				if( ! this.pageMatch( 'search.php' )) { reject( 'Search not directed to search page' ); }
				await this.page.waitFor( 5000 ); // MW Workaround; cache loading should fire events
				await this.click( `button[data-type="${mode}"]` ); 

				resolve(); 

			} catch( e ) { 
				reject( e ); 
			} 
		}); 
	}

	oneHop()   { return this.searchMode( '1hop'   ); }
	twoHop()   { return this.searchMode( '2hop'   ); }
	threeHop() { return this.searchMode( '3hop'   ); }
	clique()   { return this.searchMode( 'clique' ); }

	// ============================================================
	search() {
	// ============================================================
		let list = [];
		for( let i = 0; i < arguments.length; i++ ) { list.push( arguments[ i ]); }

		return new Promise( async ( resolve, reject ) => {
			let enter = String.fromCharCode( 13 );
			try {
				await this.click( '.search-input' );
				await this.type( `puppeteer responsivity is unreliable${enter}` ); // MW
				for( let dgr of list ) {
					console.log( `Searching for ${dgr}` );
					await this.click( '.search-input' );
					await this.type( `${dgr}${enter}` );
				}

				resolve();
			} catch( e ) {
				reject( e );
			}
		});
	}


  allNodes(){
    return this.page.evaluate(() => {
    let nodes = GeneDive.graph.graph.nodes();
    let arr = {}
    for (let i = 0; i < nodes.length; i++){
      arr[nodes[i].data().name] = nodes[i].position();
    }
    return arr;
  })
  }

//Graph - click on node
  clickOnNodeInGraph(nodeName) {
    const PAGE = this.page;

    return new Promise(async function (resolve, reject) {

      // Get the graph position, size, and zoom level
      let graph_pos = await PAGE.evaluate((nodeName) => {
        const element = $("#graph")[0];
        const {x, y, width, height} = element.getBoundingClientRect();
        const zoom = GeneDive.graph.graph.zoom();
        const pan = GeneDive.graph.graph.pan();
        return {left: x, top: y, panX: pan.x, panY: pan.y, zoom};
      }, nodeName).catch((reason) => {
        reject(reason)
      });
      // Get the node position
      let node_pos = await PAGE.evaluate((nodeName) => {
        let nodes = GeneDive.graph.graph.nodes();
        for (let i = 0; i < nodes.length; i++){

          if (nodes[i].data().name === nodeName) {
            return nodes[i].position();
          }
        }

        return null;

      }, nodeName).catch((reason) => {
        reject(reason)
      });

      if (node_pos === null)
        reject(`Unable to find node named ${nodeName}`);
      const mouse = PAGE.mouse;

      // The origin of the graph is the center, which is where the node positions are relative. So we get the position
      // of the graph's origin relative to the browser window, and then add the node positions.
      // However, the graph could be zoomed so you have to multiply the node positions by the zoom value
      const nodeLeft = graph_pos.left + graph_pos.panX + (node_pos.x * graph_pos.zoom);
      const nodeTop = graph_pos.top + graph_pos.panY + (node_pos.y * graph_pos.zoom);
      await mouse.move(nodeLeft, nodeTop).catch((reason) => {
        reject(reason)
      });

      // Click the node
      await mouse.down().catch((reason) => {
        reject(reason)
      });
      await PAGE.waitFor(50);
      await mouse.up().catch((reason) => {
        reject(reason)
      });

      resolve(`Node ${nodeName} clicked`)
    })
  }
//get table of contents
  getTableContents() {
    return this.page.evaluate(
      (table) => {
        let returnTableValues = [];
        let tableHeaders = [];
        let tableElement = $(table)[0];
        let rows = tableElement.rows;
        let DGRNumber = 0;
	//check display style
	//if(tableElement.style.display !== "none"){
        for (let r = 0; r < rows.length; r++) {
          if (rows[r].cells[0].tagName.toLowerCase() === "th")
            for (let h = 0; h < rows[r].cells.length; h++) {
              let text = rows[r].cells[h].textContent;
              if (text === "DGR") {
                DGRNumber += 1;
                tableHeaders[h] = text + DGRNumber;
              }
              else
                tableHeaders[h] = text;
            }
          else {
            let rowObj = {};
            for (let c = 0; c < rows[r].cells.length; c++) {
              let text ="";
              // Only get the text in the cell, not text in children (temp fix for bug)
              let element = rows[r].cells[c];
              for (let i = 0; i < element.childNodes.length; ++i)
                if (element.childNodes[i].nodeType === 3)
                  text += element.childNodes[i].textContent;
              rowObj[tableHeaders[c]] = text.trim();
	      rowObj[tableHeaders[c]] = element.textContent;
            }
            returnTableValues.push(rowObj);
          }

        }
	//	}
        return returnTableValues;

      }, this.ui.element.table
    );
  }

//get the column number according to filter type
  getColumnNumber(filterType) {
    let rows = document.querySelectorAll('thead tr th');
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].innerHTML.includes(filterType)) {
        return i;
      }
    }
    return console.error('Row not found');
  }
  
  //highlight rows in table
    highlightText(text, clear){
      const thisClass = this;
      // By default, the field will be cleared
      if(clear === undefined)
        clear = true;

      return new Promise(async function (resolve, reject) {
        // Clear field
        if(clear)
          await thisClass.page.evaluate((e) => {
            document.querySelector(e).value = ""
          }, thisClass.HIGHLIGHT_FILTER);

        // Get current value
        let currentFilterValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        // click the field and type in
        await thisClass.page.click(thisClass.HIGHLIGHT_FILTER).catch((reason) => {reject(reason);});
        await thisClass.page.keyboard.type(text, {delay: thisClass._TYPING_SPEED}).catch((reason) => {reject(reason);}); // type in characters
        let newValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        if(newValue !== currentFilterValue + text)
          reject(`When typing in  "${text}", the final value in the field didn't match`);
        resolve("Correct value typed in filter");
      });
    }

  //navigate back - undo
  goBackInHistory() {
    const UNDO_BUTTON = ".btn.undo";
    const thisClass = this;
    return new Promise(async function (resolve, reject) {
      // if the button isn't disabled, click it and return true
      let flag = await thisClass.page.evaluate(`!$("${UNDO_BUTTON}")[0].disabled`);
      if(flag)
      {
        await thisClass.page.click(UNDO_BUTTON).catch((reason)=>{reject(reason)});
      }
      // if the button is disabled, return false else true
        resolve(flag);
    });
  }


  //navigate forward - redo
  goForwardInHistory() {
      const REDO_BUTTON = ".btn.redo";
      const thisClass = this;
      return new Promise(async function (resolve, reject) {

        // if the button isn't disabled, click it and return true
        if(await thisClass.page.evaluate(`!$("${REDO_BUTTON}")[0].disabled`))
        {
          await thisClass.page.click(REDO_BUTTON).catch((reason)=>{reject(reason)});
          resolve(true);
        }
        // if the button is disabled, return false else true
          resolve(false);
      });
    }

    //take screenshot of the page
      screenShotEntirePage(filename) {
        const thisClass = this;
        const screenshot_location = this.SCREENSHOTS_FOLDER + filename;
        return new Promise(async function (resolve, reject) {
          let element = await thisClass.page.$('.main-display').catch((reason) => {
            reject(reason)
          });
          element.screenshot({path: screenshot_location})
            .then((reason) => {
              resolve(reason);
            })
            .catch((reason) => {
              reject(reason);
            });
        });
      }

	/**
	* Creates the response to send back. The data sent back should contain Timestamp, Test Name, Error message and code,
	* Severity, timestamp, stack trace.
	* @param success boolean
	*/
	result( success, message, severity ) {

		let status = (success ? 'pass' : 'fail' );
		let now    = new Date();
		return {
			name:      this.name,
			time:      now.toString(),
			time_unix: now.getTime(),
			status:    status,
			message:   message,
			severity:  severity,
		}
	}
}

module.exports = Test;
