/**
 * @class      Test
 * @brief      The testing superclass
 * @details    This class is subclassed by all tests. It contains commonly used methods during tests to streamline
 * test creation.
 * @authors    Jack Cole jcole2@mail.sfsu.edu
 * @ingroup    tests
 */

const severity = { none: 0, info: 1, warning: 2, error: 3, fatal: 4 };

class Test {

	static get severity()     { return severity; }
	get name()                { return "Test"; }
	get browser()             { return this._browser; }
	get page()                { return this._page; }
	get options()             { return this._options; }

	// ============================================================
	constructor( page, browser, options ) {
	// ============================================================
		this._browser             = browser;
		this._page                = page;
		this._options             = options;

		this.ui = { element : {
				table          : '.table',           // TABLE
				minProbSlider  : '.min-prob-slider', // MIN_SCORE
				highlightInput : '.highlight-input', // HIGHLIGHT_FILTER
				filterInput    : '.filter-input',    // FILTER_INPUT
			}
		}
	}

	/**
	* Runs the test
	* @return {Promise}
	*/
	// ============================================================
	async execute() {
	// ============================================================
		return new Promise(( resolve, reject ) => {
			reject( 'The Test class must be inherited for implementation.' );
		})
	}

	// Fundamental UI
	// ============================================================
	async navigate( url ) {
	// ============================================================
		await this.page.goto( url, { waitUntil: 'networkidle2' }).catch(( reason )=>{ reject( `Unable to connect. ${reason}` )});
		await this.page.addScriptTag({ url: 'http://localhost:8080/static/jquery/jquery-3.2.1.min.js' }); // Inject jQuery
		return this.pageToLoad();
	}

	// Fundamental UI
	// ============================================================
	async click( target ) {
	// ============================================================
		return this.page.click( target );
	}

	// Fundamental UI
	// ============================================================
	async type( text ) {
	// ============================================================
		return this.page.keyboard.type( text, { delay: this.options.puppeteer.typingSpeed });
	}

	// Fundamental UI
	// ============================================================
	async pageToLoad() {
	// ============================================================
		return this.page.waitForNavigation({ timeout: 3000, waitUntil: 'networkidle2' }).catch(() => {});
	}

	// ============================================================
	pageMatch( pattern ) {
	// ============================================================
		if( typeof pattern === 'object' && pattern instanceof RegExp ) {
			return this.page.url().split("/").pop().match( pattern );
		} else if( typeof pattern === 'string' ) {
			return this.page.url().split("/").pop().match( new RegExp( pattern ));
		}
	}

	// LOGIN
	// ============================================================
	login() {
	// ============================================================
		return new Promise( async( resolve, reject ) => {
			try {
				console.log( `Connecting to ${this.options.url}` );
				await this.navigate( this.options.url );
				if( this.options.login === undefined || this.options.login === undefined ) reject( 'Login or Password not set' );

				await this.click( '#email' );
				await this.type( this.options.login );
				await this.click( '#password' );
				await this.type( this.options.password );
				await this.click( 'button' );
				await this.pageToLoad();
				if( this.page.url().split( '/' ).pop() !== "search.php" ) {
					reject( "Login not redirected to search.php" );
				}
				//if logged in successfully
				resolve();
			} catch( e ) {
				reject( e );
			}
		});
	}

	//logout
	logout(){
		return new Promise( async( resolve, reject )=>{
			try{
				//logout
				await this.page.evaluate( `$('a.logoutbtn')[0].click()` ).catch(( reason ) => {
				reject( reason )
			});
			await this.page.waitForNavigation({ timeout: 5000, waitUntil: 'networkidle2' }).catch(()=>{});

			//navigate to index.php
			if( this.page.url().split("/").pop() !=="index.php" ) {
				reject( "Was not redirected to index.php" );
			}
			//logged of Successfully
				resolve();
			} catch( e ) {
				reject( e );
			}
		});
	}


//navigate to search page
  startAtSearchPage() {
    const thisClass = this;
    return new Promise(async function (resolve, reject) {
      await thisClass.page.setViewport({width: thisClass.DEFAULT_WIDTH, height: thisClass.DEFAULT_HEIGHT})
        .catch((reason) => {
		reject(reason);
        });
	//await this.userLogin();
	    
	    await thisClass.page.goto(thisClass.DOMAIN + thisClass.SEARCH_PAGE, {waitUntil: 'networkidle2'})
        .then((reason) => {
          resolve(reason);
        })
        .catch((reason) => {
          reject(reason);
        });
    })

  }
//search method
  searchDGRs(dgrs, type) {
    const SEARCH_FIELD = ".search-input";
    const ALLOWED_TYPES = {"clique": true, "1hop": true, "2hop": true, "3hop": true,};
    const thisClass = this;

    return new Promise(async function (resolve, reject) {
      let fieldHasCorrectValue;
      if (!type in ALLOWED_TYPES)
        reject("Invalid type specified. Must be a string with one of the following:", Object.keys(ALLOWED_TYPES));
      // Check if the dgrs are an array
      if (dgrs.constructor !== Array)
        reject("Invalid dgrs passed in. Must be an Array.");
      await thisClass.page.click(`.topology-selector [data-type="${type}"]`, {waitUntil: 'networkidle2'}).catch((reason) => {
        reject(reason);
      });

      // Try to add each DGR
      for (let i in dgrs) {
        let dgr = dgrs[i];
        fieldHasCorrectValue = false;

       // Clear element value
          await thisClass.page.evaluate((e) => {
            document.querySelector(e).value = ""
          }, SEARCH_FIELD);
          await thisClass.page.click(SEARCH_FIELD).catch((reason) => {reject(reason);}); // click on element
 // Will try to input the search text over and over until it finally fills it in, or 5 tries have passed
    for (let j = 0; !fieldHasCorrectValue && j < 5; j++) {
	     await thisClass.page.type(SEARCH_FIELD,dgr,{delay: thisClass._TYPING_SPEED}).catch((reason) => {reject(reason);}); // type in characters
	     fieldHasCorrectValue = await thisClass.page.evaluate((e) => document.querySelector(e).value, SEARCH_FIELD) === dgr;
	     if(fieldHasCorrectValue)
		     break;
	     await thisClass.page.waitFor(30); // Wait a few seconds for autocomplete
	       }

        // If it still couldn't enter the value
        if (!fieldHasCorrectValue)
          reject("Could not input value into search field");
        // Press ENTER and wait for the page to stop loading.
        thisClass.page.keyboard.press('Enter').catch((reason) => {
          reject(reason);
        });
        await thisClass.page.waitFor(100);//wait for page to load
        await thisClass.waitForPageToFinishLoading().catch((reason) => {
          reject(reason);
        });
      }
      resolve(`Completed ${type} search of ${dgrs}`);
    });
  }

  allNodes(){
    return this.page.evaluate(() => {
    let nodes = GeneDive.graph.graph.nodes();
    let arr = {}
    for (let i = 0; i < nodes.length; i++){
      arr[nodes[i].data().name] = nodes[i].position();
    }
    return arr;
  })
  }

//Graph - click on node
  clickOnNodeInGraph(nodeName) {
    const PAGE = this.page;

    return new Promise(async function (resolve, reject) {

      // Get the graph position, size, and zoom level
      let graph_pos = await PAGE.evaluate((nodeName) => {
        const element = $("#graph")[0];
        const {x, y, width, height} = element.getBoundingClientRect();
        const zoom = GeneDive.graph.graph.zoom();
        const pan = GeneDive.graph.graph.pan();
        return {left: x, top: y, panX: pan.x, panY: pan.y, zoom};
      }, nodeName).catch((reason) => {
        reject(reason)
      });
      // Get the node position
      let node_pos = await PAGE.evaluate((nodeName) => {
        let nodes = GeneDive.graph.graph.nodes();
        for (let i = 0; i < nodes.length; i++){

          if (nodes[i].data().name === nodeName) {
            return nodes[i].position();
          }
        }

        return null;

      }, nodeName).catch((reason) => {
        reject(reason)
      });

      if (node_pos === null)
        reject(`Unable to find node named ${nodeName}`);
      const mouse = PAGE.mouse;

      // The origin of the graph is the center, which is where the node positions are relative. So we get the position
      // of the graph's origin relative to the browser window, and then add the node positions.
      // However, the graph could be zoomed so you have to multiply the node positions by the zoom value
      const nodeLeft = graph_pos.left + graph_pos.panX + (node_pos.x * graph_pos.zoom);
      const nodeTop = graph_pos.top + graph_pos.panY + (node_pos.y * graph_pos.zoom);
      await mouse.move(nodeLeft, nodeTop).catch((reason) => {
        reject(reason)
      });

      // Click the node
      await mouse.down().catch((reason) => {
        reject(reason)
      });
      await PAGE.waitFor(50);
      await mouse.up().catch((reason) => {
        reject(reason)
      });

      resolve(`Node ${nodeName} clicked`)
    })
  }
//get table of contents
  getTableContents() {
    return this.page.evaluate(
      (table) => {
        let returnTableValues = [];
        let tableHeaders = [];
        let tableElement = $(table)[0];
        let rows = tableElement.rows;
        let DGRNumber = 0;
	//check display style
	//if(tableElement.style.display !== "none"){
        for (let r = 0; r < rows.length; r++) {
          if (rows[r].cells[0].tagName.toLowerCase() === "th")
            for (let h = 0; h < rows[r].cells.length; h++) {
              let text = rows[r].cells[h].textContent;
              if (text === "DGR") {
                DGRNumber += 1;
                tableHeaders[h] = text + DGRNumber;
              }
              else
                tableHeaders[h] = text;
            }
          else {
            let rowObj = {};
            for (let c = 0; c < rows[r].cells.length; c++) {
              let text ="";
              // Only get the text in the cell, not text in children (temp fix for bug)
              let element = rows[r].cells[c];
              for (let i = 0; i < element.childNodes.length; ++i)
                if (element.childNodes[i].nodeType === 3)
                  text += element.childNodes[i].textContent;
              rowObj[tableHeaders[c]] = text.trim();
	      rowObj[tableHeaders[c]] = element.textContent;
            }
            returnTableValues.push(rowObj);
          }

        }
	//	}
        return returnTableValues;

      }, this.ui.element.table
    );
  }

//get the column number according to filter type
  getColumnNumber(filterType) {
    let rows = document.querySelectorAll('thead tr th');
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].innerHTML.includes(filterType)) {
        return i;
      }
    }
    return console.error('Row not found');
  }
  
//wait for page to load
	waitForPageToFinishLoading() {
		return this.page.waitForFunction( 'GeneDive.spinneractive === false' );
	}

  //highlight rows in table
    highlightText(text, clear){
      const thisClass = this;
      // By default, the field will be cleared
      if(clear === undefined)
        clear = true;

      return new Promise(async function (resolve, reject) {
        // Clear field
        if(clear)
          await thisClass.page.evaluate((e) => {
            document.querySelector(e).value = ""
          }, thisClass.HIGHLIGHT_FILTER);

        // Get current value
        let currentFilterValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        // click the field and type in
        await thisClass.page.click(thisClass.HIGHLIGHT_FILTER).catch((reason) => {reject(reason);});
        await thisClass.page.keyboard.type(text, {delay: thisClass._TYPING_SPEED}).catch((reason) => {reject(reason);}); // type in characters
        let newValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        if(newValue !== currentFilterValue + text)
          reject(`When typing in  "${text}", the final value in the field didn't match`);
        resolve("Correct value typed in filter");
      });
    }

  //navigate back - undo
  goBackInHistory() {
    const UNDO_BUTTON = ".btn.undo";
    const thisClass = this;
    return new Promise(async function (resolve, reject) {
      // if the button isn't disabled, click it and return true
      let flag = await thisClass.page.evaluate(`!$("${UNDO_BUTTON}")[0].disabled`);
      if(flag)
      {
        await thisClass.page.click(UNDO_BUTTON).catch((reason)=>{reject(reason)});
      }
      // if the button is disabled, return false else true
        resolve(flag);
    });
  }


  //navigate forward - redo
  goForwardInHistory() {
      const REDO_BUTTON = ".btn.redo";
      const thisClass = this;
      return new Promise(async function (resolve, reject) {

        // if the button isn't disabled, click it and return true
        if(await thisClass.page.evaluate(`!$("${REDO_BUTTON}")[0].disabled`))
        {
          await thisClass.page.click(REDO_BUTTON).catch((reason)=>{reject(reason)});
          resolve(true);
        }
        // if the button is disabled, return false else true
          resolve(false);
      });
    }

    //take screenshot of the page
      screenShotEntirePage(filename) {
        const thisClass = this;
        const screenshot_location = this.SCREENSHOTS_FOLDER + filename;
        return new Promise(async function (resolve, reject) {
          let element = await thisClass.page.$('.main-display').catch((reason) => {
            reject(reason)
          });
          element.screenshot({path: screenshot_location})
            .then((reason) => {
              resolve(reason);
            })
            .catch((reason) => {
              reject(reason);
            });
        });
      }

	/**
	* Creates the response to send back. The data sent back should contain Timestamp, Test Name, Error message and code,
	* Severity, timestamp, stack trace.
	* @param success boolean
	*/
	result( success, message, severity ) {

		let status = (success ? 'pass' : 'fail' );
		let now    = new Date();
		return {
			name:      this.name,
			time:      now.toString(),
			time_unix: now.getTime(),
			status:    status,
			message:   message,
			severity:  severity,
		}
	}
}

module.exports = Test;
