/**
 * @class      Test
 * @brief      The testing superclass
 * @details    This class is subclassed by all tests. It contains commonly used methods during tests to streamline
 * test creation.
 * @authors    Mike Wong mikewong@sfsu.edu, Jack Cole jcole2@mail.sfsu.edu
 * @ingroup    tests
 */

const severity = { none: 0, info: 1, warning: 2, error: 3, fatal: 4 };

class Test {

	static get severity()     { return severity; }
	get name()                { return "Test"; }
	get browser()             { return this._browser; }
	get page()                { return this._page; }
	get options()             { return this._options; }

	// ============================================================
	constructor( page, browser, options ) {
	// ============================================================
		this._browser             = browser;
		this._page                = page;
		this._options             = options;

		this.page.is = {
			searchPage: () => { return this.pageMatch( /\bsearch.php$/ ); },
			indexPage:  () => { return this.pageMatch( /\bindex.php$/ ); }
		};
		this.goto = {
			searchPage: () => { return this.navigate( `${this.options.url}/search.php` ); },
			indexPage:  () => { return this.navigate( `${this.options.url}/index.php` ); },
		};
	}

	/**
	* Runs the test
	* @return {Promise}
	*/
	// ============================================================
	async execute() {
	// ============================================================
		return new Promise(( resolve, reject ) => {
			reject( 'The Test class must be inherited for implementation.' );
		})
	}

	// Fundamental UI
	// ============================================================
	async navigate( url ) {
	// ============================================================
		if( typeof url === 'undefined' ) { url = this.options.url; }
		if( ! url.match( /^http/i )) { url = `${this.options.url}/${url}`; url = url.replace( /\/+/g, '/' ); url = url.replace( 'http:/', 'http://' ); url = url.replace( 'https:/', 'https://' ); }
		await this.page.goto( url, { waitUntil: 'networkidle2' }).catch(( reason )=>{ reject( `Unable to connect. ${reason}` )});
		return this.pageToLoad();
	}

	// Fundamental UI
	// ============================================================
	async click( target ) {
	// ============================================================
		await this.page.click( target, { delay: 100 }); // Emulate user clicking mouse (not instantaneous)
		return this.page.waitFor( 500 );                // Emulate user pause after clicking with mouse
	}

	// Fundamental UI
	// ============================================================
	async type( text ) {
	// ============================================================
		return this.page.keyboard.type( text, { delay: this.options.puppeteer.typingSpeed });
	}

	// Fundamental UI
	// ============================================================
	async pageToLoad() {
	// ============================================================
		return this.page.waitForNavigation({ timeout: 3000, waitUntil: 'networkidle2' }).catch(() => {});
	}

	// ============================================================
	pageMatch( pattern ) {
	// ============================================================
		let url = String( this.page.url().split( '/' ).pop() );

		if( typeof pattern === 'string' ) { pattern = new RegExp( pattern ); }

		return url.match( pattern );
	}

	// ============================================================
	login() {
	// ============================================================
		return new Promise( async( resolve, reject ) => {
			try {
				await this.navigate();
				if( this.options.login === undefined || this.options.login === undefined ) reject( 'Login or Password not set' );

				await this.click( '#email' );
				await this.type( this.options.login );
				await this.click( '#password' );
				await this.type( this.options.password );
				await this.click( 'button' );
				await this.pageToLoad();
				if( ! this.page.is.searchPage()) { reject( 'Login not redirected to search page' ); }
				resolve();

			} catch( e ) {
				reject( e );
			}
		});
	}

	// ============================================================
	logout() {
	// ============================================================
		return new Promise( async ( resolve, reject ) => {
			try {
				await this.click( '.user-info-and-logout a' );
				await this.pageToLoad();
			
				if( ! this.page.is.indexPage()) { reject( 'Logout not redirected to landing page' ); }
				resolve();

			} catch( e ) {
				reject( e );
			}
		});
	}
	
	// ============================================================
	// Search Modes
	// ============================================================
	// The various search modes have tooltips, which cause a subtle
	// delay in UI timing. After clicking the button, a user will
	// typically wait for the tooltip to go away on its own.
	// ------------------------------------------------------------
	searchMode( mode ) {
		return new Promise( async ( resolve, reject ) => { 
			try { 
				if( ! this.page.is.searchPage()) { reject( 'Search not directed to search page' ); }
				await this.pageToLoad(); // Allow cache results to load via AJAX call
				await this.page.waitForSelector( '.table-help, .table, .no-results', { visible: true }); // Search is ready when the help page, results table, or no results are displayed
				await this.click( `button[data-type="${mode}"]` ); 
				await this.page.mouse.move( 0, 0 ); // Move the mouse away from the button to dismiss the tooltip

				resolve(); 

			} catch( e ) { 
				reject( e ); 
			} 
		}); 
	}

	oneHop()   { return this.searchMode( '1hop'   ); }
	twoHop()   { return this.searchMode( '2hop'   ); }
	threeHop() { return this.searchMode( '3hop'   ); }
	clique()   { return this.searchMode( 'clique' ); }

	// ============================================================
	search() {
	// ============================================================

		// Flatten argument lists
		let list = [];
		for( let i = 0; i < arguments.length; i++ ) { 
			if( Array.isArray( arguments[ i ] )) {
				list = list.concat( arguments[ i ]);
			} else if( typeof arguments[ i ] === 'string' ) {
				list.push( arguments[ i ]); 
			} else {
				reject( 'Test.search method takes lists and strings as arguments' );
			}
		}

		return new Promise( async ( resolve, reject ) => {
			let enter = String.fromCharCode( 13 );
			try {
				for( let dgr of list ) {
					await this.page.waitFor( 500 ); // Simulate brief user thinking prior
					await this.click( '.search-input' );
					await this.type( `${dgr}${enter}` );
				}
				await this.page.waitForSelector( '.table', { visible: true }); // Search is complete when table of results is rendered

				resolve();
			} catch( e ) {
				reject( e );
			}
		});
	}

//get the column number according to filter type
  getColumnNumber(filterType) {
    let rows = document.querySelectorAll('thead tr th');
    for (let i = 0; i < rows.length; i++) {
      if (rows[i].innerHTML.includes(filterType)) {
        return i;
      }
    }
    return console.error('Row not found');
  }
  
  //highlight rows in table
    highlightText(text, clear){
      const thisClass = this;
      // By default, the field will be cleared
      if(clear === undefined)
        clear = true;

      return new Promise(async function (resolve, reject) {
        // Clear field
        if(clear)
          await thisClass.page.evaluate((e) => {
            document.querySelector(e).value = ""
          }, thisClass.HIGHLIGHT_FILTER);

        // Get current value
        let currentFilterValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        // click the field and type in
        await thisClass.page.click(thisClass.HIGHLIGHT_FILTER).catch((reason) => {reject(reason);});
        await thisClass.page.keyboard.type(text, {delay: thisClass._TYPING_SPEED}).catch((reason) => {reject(reason);}); // type in characters
        let newValue = await thisClass.page.evaluate(
          (filter) => {return $(filter).val()}, thisClass.HIGHLIGHT_FILTER
        ).catch((reason) => {reject(reason);});

        if(newValue !== currentFilterValue + text)
          reject(`When typing in  "${text}", the final value in the field didn't match`);
        resolve("Correct value typed in filter");
      });
    }

  //navigate back - undo
  goBackInHistory() {
    const UNDO_BUTTON = ".btn.undo";
    const thisClass = this;
    return new Promise(async function (resolve, reject) {
      // if the button isn't disabled, click it and return true
      let flag = await thisClass.page.evaluate(`!$("${UNDO_BUTTON}")[0].disabled`);
      if(flag)
      {
        await thisClass.page.click(UNDO_BUTTON).catch((reason)=>{reject(reason)});
      }
      // if the button is disabled, return false else true
        resolve(flag);
    });
  }


  //navigate forward - redo
  goForwardInHistory() {
      const REDO_BUTTON = ".btn.redo";
      const thisClass = this;
      return new Promise(async function (resolve, reject) {

        // if the button isn't disabled, click it and return true
        if(await thisClass.page.evaluate(`!$("${REDO_BUTTON}")[0].disabled`))
        {
          await thisClass.page.click(REDO_BUTTON).catch((reason)=>{reject(reason)});
          resolve(true);
        }
        // if the button is disabled, return false else true
          resolve(false);
      });
    }

    //take screenshot of the page
      screenShotEntirePage(filename) {
        const thisClass = this;
        const screenshot_location = this.SCREENSHOTS_FOLDER + filename;
        return new Promise(async function (resolve, reject) {
          let element = await thisClass.page.$('.main-display').catch((reason) => {
            reject(reason)
          });
          element.screenshot({path: screenshot_location})
            .then((reason) => {
              resolve(reason);
            })
            .catch((reason) => {
              reject(reason);
            });
        });
      }

	/**
	* Creates the response to send back. The data sent back should contain Timestamp, Test Name, Error message and code,
	* Severity, timestamp, stack trace.
	* @param success boolean
	*/
	result( success, message, severity ) {

		let status = (success ? 'pass' : 'fail' );
		let now    = new Date();
		return {
			name:      this.name,
			time:      now.toString(),
			time_unix: now.getTime(),
			status:    status,
			message:   message,
			severity:  severity,
		}
	}
}

module.exports = Test;
