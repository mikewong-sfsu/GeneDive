/**
 * @class     Graph
 * @brief     Results Graph Viewer API
 * @details   Automates the MVC Graph Viewer.
 * @authors   Mike Wong mikewong@sfsu.edu
 * @ingroup   MVC
 */

let Graph = (superclass) => class extends superclass {

	// ============================================================
	graphPosition() {
	// ============================================================
		let graph = { ui: $( '#graph' )[ 0 ]};
		return this.page.evaluate(() => {
			graph.cs                    = GeneDive.graph.graph; // Graph Cytoscape interface
			const {x, y, width, height} = graph.ui.getBoundingClientRect();
			const zoom                  = graph.cs.zoom();
			const pan                   = graph.cs.pan();

			return { left: x, top: y, panX: pan.x, panY: pan.y, zoom };
		}).catch(( reason ) => { reject( reason )});
	}
	// MW HTML Collection to Array?

	// ============================================================
	nodePosition( name ) {
	// ============================================================
		return this.page.evaluate(( name ) => {
			let nodes = GeneDive.graph.graph.nodes();
			for (let i = 0; i < nodes.length; i++) {
				if( nodes[ i ].data().name != name ) { continue; }
				return nodes[ i ].position();
			}

			return null;
		}, name ).catch(( reason ) => { reject( reason )});
	}

	// ============================================================
	clickGraphNode( name ) {
	// ============================================================
	// The origin of the graph is the center, which is where the node positions
	// are relative. So we get the position of the graph's origin relative to
	// the browser window, and then add the node positions. Positions are
	// scaled relative to the zoom value 
	// ------------------------------------------------------------
		return new Promise( async function ( resolve, reject ) {
			let graph = { ui: $( '#graph' )[ 0 ], pos: await this.graphPosition()};
			let node  = { name: name, pos: await this.nodePosition( name )};

			if( node.pos === null ) { reject( `Unable to find node named ${name}` ); }

			node.left = graph.pos.left + graph.pos.panX + (node.pos.x * graph.pos.zoom);
			node.top  = graph.pos.top  + graph.pos.panY + (node.pos.y * graph.pos.zoom);
			await this.page.mouse.move( node.left, node.top ).catch(( reason ) => { reject(reason) });

			// Click the node
			await this.page.mouse.down().catch(( reason ) => { reject( reason )});
			await this.page.waitFor( 50 ); // Emulate a human click
			await this.page.mouse.up().catch(( reason ) => { reject( reason )});

			resolve( `Node ${name} clicked at (${node.left}, ${node.top})` )
		})
	}

}

module.exports = Graph;
