#! /usr/bin/perl

BEGIN { $| = 1; } # Forces output buffer to flush

use Text::CSV qw( csv );
use List::Util qw( any none uniq );
use JSON::XS;

my $file         = shift; # Absolute path
my $cache        = cache( $file );
my $path         = path( $file );
my @required     = qw( mention1 mention2 geneids1 geneids2 type1 type2 );
my @optional     = qw( journal article_id pubmed_id sentence_id mention1_offset mention2_offset probability context section);
my $interactions = csv( in => validate( $file ), encoding => 'utf-8', headers => "auto" );

# ===== CLEANUP
cleanup( $interactions );

# ===== GENERATE ADJACENCY MATRIX
print "<ul><li><i>Adjacency matrix</i></li>\n";
adjacency_matrix( $cache, $interactions );

# ===== GENERATE TYPEAHEAD LOOKUP CACHES
foreach my $type (qw( gene drug disease )) {
	my $hash = {};
	extract_ids( $type, $hash, $_ ) foreach @$interactions;
	hash_to_cache( $type, $cache, $hash );
	printf "<li><i>%s typeahead lookup cache</i></li>\n", ucfirst( $type );
}

filter_columns( $interactions );
print "</ul>Preparing to load data into the database<br>\n";
write_sql( $path, $interactions );

# ============================================================
sub adjacency_matrix {
# ============================================================
	my $cache        = shift;
	my $interactions = shift;

	my $matrix = {};

	foreach my $interaction (@$interactions) {
		my $a    = $interaction->{ geneids1 };
		my $b    = $interaction->{ geneids2 };
		my $p    = $interaction->{ probability };

		$matrix->{ $a }{ $b } = [] if not exists $matrix->{ $a }{ $b };
		$matrix->{ $a }{ $b } = [ sort { $a <=> $b } (($p*1000), @{ $matrix->{ $a }{ $b }})];
		$matrix->{ $b }{ $a } = $matrix->{ $a }{ $b }; # Enforce bidirectionality
	}

	my $json = new JSON::XS();
	unless( -d $cache ) { mkdir $cache; chmod 0777, $cache; }
	open FILE, ">$cache/adjacency_matrix.js" or die "Can't write to '$cache/adjacency_matrix.js' $!";
	print FILE "var adjacency_matrix = ";
	print FILE $json->canonical->encode( $matrix );
	print FILE ";";
	close FILE;
}

# ============================================================
sub cache {
# ============================================================
	my $file  = shift;
	my @paths = split /\//, $file; pop @paths;
	my $cache = '/var/www/html/cache/';
	my $path  = $cache . pop @paths;

	return $path;
}

# ============================================================
sub cleanup {
# ============================================================
	my $interactions = shift;
	foreach my $i (@$interactions) {
		$i->{ type1 } = lc $i->{ type1 };
		$i->{ type2 } = lc $i->{ type2 };
		if( exists $i->{ id1 }) { $i->{ geneids1 } = $i->{ id1 }; delete $i->{ id1 }; }
		if( exists $i->{ id2 }) { $i->{ geneids2 } = $i->{ id2 }; delete $i->{ id2 }; }
		if( ! exists $i->{ probability }) { $i->{ probability } = 0.7; }
	}
}

# ============================================================
sub double_quote {
# ============================================================
	my $value = shift;
	$value =~ s/"/""/g;
	return "\"$value\"";
}

# ============================================================
sub filter_columns {
# ============================================================
	my $interactions = shift;
	my $denied = [ grep { my $field = $_; none { $field eq $_ } (@required, @optional) } keys %{$interactions->[ 0 ]}];
	foreach my $interaction (@$interactions) {
		delete $interaction->{ $_ } foreach @$denied;
	}
}

# ============================================================
sub extract_ids {
# ============================================================
	my $type    = shift;
	my $hash    = shift;
	my $entry   = shift;

	foreach my $i ( 1, 2 ) {
		next unless( $entry->{ "type$i" } eq $type );
		my $id     = $entry->{ "geneids$i" };
		my $symbol = $entry->{ "mention$i" };
		push @{$hash->{ $symbol }}, $id;
	}
}

# ============================================================
sub hash_to_cache {
# ============================================================
	my $type  = shift;
	my $cache = shift;
	my $hash  = shift;
	my $json  = new JSON::XS();

	my $data = [];
	foreach my $key (sort { $a cmp $b } keys %$hash) {
		push @$data, { symbol => $key, values => [ uniq @{$hash->{ $key }} ]};
	}

	unless( -d $cache ) { mkdir $cache; chmod 0777, $cache; }
	open FILE, ">$cache/$type" . '_id.js' or die $!;
	printf FILE "var AUTOCOMPLETE_%s = ", uc( $type );
	print FILE $json->canonical->encode( $data );
	print FILE ";";
	close FILE;
}

# ============================================================
sub insert_table {
# ============================================================
return <<EOF;
CREATE TABLE IF NOT EXISTS interactions (
	id INTEGER NOT NULL, 
	journal TEXT, 
	article_id TEXT, 
	pubmed_id TEXT, 
	sentence_id TEXT, 
	mention1_offset INTEGER, 
	mention2_offset INTEGER, 
	mention1 TEXT collate nocase, 
	mention2 TEXT collate nocase, 
	geneids1 TEXT, 
	geneids2 TEXT, 
	probability FLOAT, 
	context TEXT, 
	section TEXT, 
	type1 CHARACTER(1), 
	type2 CHARACTER(1),
	PRIMARY KEY (id)
);
CREATE INDEX IF NOT EXISTS gid1 on interactions(geneids1);
CREATE INDEX IF NOT EXISTS gid2 on interactions(geneids2);
EOF
}

# ============================================================
sub path {
# ============================================================
	my $file  = shift;
	my @paths = split /\//, $file; pop @paths;
	my $path  = join( '/', @paths ) || '.';

	return $path;
}

# ============================================================
sub validate {
# ============================================================
	my $file     = shift;

	open FILE, $file or die $!;
	my $header = <FILE>;
	$header =~ s/\s*$//;
	close FILE;
	my @headers = split /,\s*/, $header;
	my $alias = { geneids1 => 'id1', geneids2 => 'id2' };

	# ===== ENFORCE REQUIRED FIELDS
	foreach my $required (@required) {
		my $aliases = exists $alias->{ $required } ? [ $alias->{ $required } ] : [];
		unless( grep { 
			my $field = $_;
			$field eq $required || any { $field eq $_ } @{$aliases}
		} @headers ) {
			printf( "<h2>Error</h2><p>Missing required field <code>%s</code></p>\n", $required );
			exit( 1 );
		}
	}

	return $file;
}

# ============================================================
sub write_sql {
# ============================================================
	my $path         = shift;
	my $interactions = shift;

	my $file = "$path/data.import.sql";
	my $last = $#$interactions;
	open FILE, ">:encoding(UTF-8)", $file or die $!;
	print FILE insert_table();
	my $group = 1000; # Max number of rows for INSERT for SQLite3
	my @columns = map { exists $alias->{ $_ } ? $alias->{ $_ } : $_ } (@required, @optional);
	foreach my $i ( 0 .. $last ) {
		my $end_of_data    = ($i == $last);
		my $start_of_group = (($i % $group) == 0);
		my $end_of_group   = ($i % $group == ($group - 1));
		if( $start_of_group ) { 
			printf FILE "insert into interactions (%s) values\n", join( ', ', @columns );
		};
		my $interaction = $interactions->[ $i ];
		my @values = ();
		foreach my $key (@columns) {
			my $exists  = exists $interaction->{ $key };
			my $numeric = qr/^(probability|mention1_offset|mention2_offset)$/;
			if( $key =~ $numeric ) {
				if( $exists ) { push @values, $interaction->{ $key }; }
				else          { push @values, 'NULL'; }
			} else {
				if( $exists ) { push @values, double_quote( $interaction->{ $key } ); }
				else          { push @values, double_quote(''); }
			}
		}
		printf FILE "( %s )%s", join( ', ', @values ), ( $end_of_group || $end_of_data ? ";\n\n" : ",\n" );
		
	}
	close FILE;
}
